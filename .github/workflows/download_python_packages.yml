name: Download Python Packages (è·³è¿‡å¤§æ–‡ä»¶ç‰ˆ)
 
on:
  workflow_dispatch:
    inputs:
      python_version:
        description: 'Python version to use'
        required: false
        default: '3.12'
      package_file:
        description: 'Path to package list file'
        required: false
        default: '.github/docs/lib_python.txt'
  schedule:
    # æ¯æœˆ9å·è‡ªåŠ¨æ›´æ–°
    - cron: '0 0 9 * *'
  push:
    paths:
      - '.github/docs/lib_python.txt'
      - '.github/scripts/*.py'
      
permissions:
  contents: write
  actions: read
  
jobs:
  download-packages:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ github.event.inputs.python_version || '3.12' }}
        
    - name: Cache pip packages
      uses: actions/cache@v3
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles(github.event.inputs.package_file || '.github/docs/lib_python.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-
          
    - name: Create Python packages directory structure
      run: |
        mkdir -p Python_packages_backup/{singlecell,machine_learning,core,visualization,genomics,immunology,deep_learning,data_processing,uncategorized}
        
    - name: Install required tools
      run: |
        pip install wheel setuptools requests pyyaml tqdm
        
    - name: Configure Git
      run: |
        git config --global user.name "GitHub Actions Bot"
        git config --global user.email "actions@github.com"
        
    - name: Make scripts executable
      run: |
        chmod +x .github/scripts/*.py
        
    - name: Parse package list
      env:
        PYTHON_VERSION: ${{ github.event.inputs.python_version || '3.12' }}
      run: |
        python .github/scripts/parse_packages.py \
          "${{ github.event.inputs.package_file || '.github/docs/lib_python.txt' }}" \
          classified_packages.yml
          
    - name: Download packages with size filter
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        GITHUB_RUN_STARTED_AT: ${{ github.run_started_at }}
        PYTHON_VERSION: ${{ github.event.inputs.python_version || '3.12' }}
        GITHUB_EVENT_NAME: ${{ github.event_name }}
        GITHUB_RUN_ID: ${{ github.run_id }}
        GITHUB_REPOSITORY: ${{ github.repository }}
        PACKAGE_FILE: ${{ github.event.inputs.package_file || '.github/docs/lib_python.txt' }}
        MAX_FILE_SIZE_MB: 100
      run: |
        # åˆ›å»ºé€ä¸ªä¸‹è½½çš„Pythonè„šæœ¬ï¼ˆå¤§å°è¿‡æ»¤ç‰ˆï¼‰
        cat > incremental_download.py << 'EOF'
        import os
        import sys
        import yaml
        import json
        import time
        import subprocess
        import shutil
        from pathlib import Path
        from tqdm import tqdm
        
        def write_progress(package_name, status, size_mb=0, category="", reason=""):
            """å†™å…¥è¿›åº¦ä¿¡æ¯"""
            progress_info = f"{package_name}|{status}|{size_mb}|{category}|{reason}"
            with open("download_progress.txt", "w") as f:
                f.write(progress_info)
            if reason:
                print(f"ğŸ“¦ è¿›åº¦æ›´æ–°: {package_name} - {status} ({size_mb}MB) - {reason}")
            else:
                print(f"ğŸ“¦ è¿›åº¦æ›´æ–°: {package_name} - {status} ({size_mb}MB)")
        
        def get_package_info_before_download(package_name):
            """åœ¨ä¸‹è½½å‰è·å–åŒ…ä¿¡æ¯ï¼Œé¢„ä¼°æ–‡ä»¶å¤§å°"""
            try:
                # ä½¿ç”¨pip showè·å–åŒ…ä¿¡æ¯
                result = subprocess.run(['pip', 'show', package_name], 
                                      capture_output=True, text=True, timeout=30)
                if result.returncode == 0:
                    lines = result.stdout.split('\n')
                    for line in lines:
                        if line.startswith('Size:'):
                            size_str = line.split(':', 1)[1].strip()
                            # å°è¯•è§£æå¤§å°
                            if 'KB' in size_str:
                                size_kb = float(size_str.replace('KB', '').strip())
                                return size_kb / 1024  # è½¬æ¢ä¸ºMB
                            elif 'MB' in size_str:
                                return float(size_str.replace('MB', '').strip())
            except:
                pass
            return None
        
        def check_file_sizes(package_dir, max_size_mb=100):
            """æ£€æŸ¥åŒ…ç›®å½•ä¸­çš„æ–‡ä»¶å¤§å°"""
            large_files = []
            total_size = 0
            
            for root, dirs, files in os.walk(package_dir):
                for file in files:
                    file_path = os.path.join(root, file)
                    if os.path.isfile(file_path):
                        file_size = os.path.getsize(file_path)
                        file_size_mb = file_size / (1024 * 1024)
                        total_size += file_size_mb
                        
                        if file_size_mb > max_size_mb:
                            large_files.append({
                                'name': file,
                                'size_mb': round(file_size_mb, 2)
                            })
            
            return large_files, round(total_size, 2)
        
        def download_single_package(package_info, backup_dir, max_size_mb=100):
            """ä¸‹è½½å•ä¸ªåŒ…"""
            package_name = package_info['name']
            category = package_info.get('category', 'uncategorized')
            
            # é¢„æ£€æŸ¥åŒ…å¤§å°ï¼ˆå¦‚æœå¯èƒ½ï¼‰
            estimated_size = get_package_info_before_download(package_name)
            if estimated_size and estimated_size > max_size_mb:
                write_progress(package_name, 'skipped_estimated_large', estimated_size, category, 
                             f"é¢„ä¼°å¤§å°: {estimated_size:.1f}MB")
                return False, 0, None
            
            # åˆ›å»ºåŒ…ç›®å½•
            category_dir = os.path.join(backup_dir, category)
            os.makedirs(category_dir, exist_ok=True)
            
            package_dir = os.path.join(category_dir, package_name)
            
            # æ¸…ç†å·²å­˜åœ¨çš„ç›®å½•
            if os.path.exists(package_dir):
                shutil.rmtree(package_dir)
            os.makedirs(package_dir)
            
            try:
                # ä½¿ç”¨pipä¸‹è½½åŒ…åˆ°æŒ‡å®šç›®å½•
                cmd = [
                    'pip', 'download', '--no-deps', '--dest', package_dir, package_name
                ]
                
                print(f"ğŸ”„ æ­£åœ¨ä¸‹è½½ {package_name}...")
                result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
                
                if result.returncode == 0:
                    # æ£€æŸ¥ä¸‹è½½çš„æ–‡ä»¶
                    files = os.listdir(package_dir)
                    if files:
                        # æ£€æŸ¥æ–‡ä»¶å¤§å°
                        large_files, total_size = check_file_sizes(package_dir, max_size_mb)
                        
                        if large_files:
                            # æœ‰å¤§æ–‡ä»¶ï¼Œè·³è¿‡æ­¤åŒ…
                            large_files_info = ", ".join([f"{f['name']}({f['size_mb']}MB)" for f in large_files])
                            write_progress(package_name, 'skipped_large_files', total_size, category, 
                                         f"å¤§æ–‡ä»¶: {large_files_info}")
                            
                            # æ¸…ç†ç›®å½•
                            shutil.rmtree(package_dir)
                            return False, 0, None
                        else:
                            # åˆ›å»ºåŒ…ä¿¡æ¯æ–‡ä»¶
                            info = {
                                'name': package_name,
                                'category': category,
                                'download_time': time.strftime('%Y-%m-%d %H:%M:%S'),
                                'files': files,
                                'size_mb': total_size,
                                'status': 'success',
                                'estimated_size': estimated_size
                            }
                            
                            with open(os.path.join(package_dir, 'package_info.json'), 'w') as f:
                                json.dump(info, f, indent=2)
                            
                            write_progress(package_name, 'success', total_size, category)
                            return True, total_size, package_dir
                    else:
                        write_progress(package_name, 'failed_no_files', 0, category, "ä¸‹è½½åæ— æ–‡ä»¶")
                        return False, 0, None
                else:
                    error_msg = result.stderr.strip() if result.stderr else f"é€€å‡ºç : {result.returncode}"
                    write_progress(package_name, 'failed_download', 0, category, error_msg[:50])
                    return False, 0, None
                    
            except subprocess.TimeoutExpired:
                write_progress(package_name, 'timeout', 0, category, "ä¸‹è½½è¶…æ—¶(300s)")
                return False, 0, None
            except Exception as e:
                write_progress(package_name, 'error', 0, category, str(e)[:50])
                return False, 0, None
        
        def main():
            if len(sys.argv) < 3:
                print("ç”¨æ³•: python incremental_download.py <classified_packages.yml> <backup_dir> [max_size_mb]")
                sys.exit(1)
            
            packages_file = sys.argv[1]
            backup_dir = sys.argv[2]
            max_size_mb = float(sys.argv[3]) if len(sys.argv) > 3 else 100.0
            
            # è¯»å–åŒ…åˆ†ç±»ä¿¡æ¯
            with open(packages_file, 'r', encoding='utf-8') as f:
                classified_packages = yaml.safe_load(f)
            
            # æ”¶é›†æ‰€æœ‰åŒ…
            all_packages = []
            for category, packages in classified_packages.items():
                for package in packages:
                    all_packages.append({
                        'name': package,
                        'category': category
                    })
            
            print(f"å¼€å§‹ä¸‹è½½ {len(all_packages)} ä¸ªPythonåŒ… (æ–‡ä»¶å¤§å°é™åˆ¶: {max_size_mb}MB)...")
            
            success_count = 0
            failed_count = 0
            skipped_count = 0
            total_size = 0
            
            # é¢„å…ˆæ£€æŸ¥å¹¶è·³è¿‡å·²çŸ¥çš„å¤§åŒ…
            known_large_packages = ['torch', 'tensorflow', 'jax', 'paddlepaddle', 'mxnet']
            filtered_packages = []
            
            for pkg_info in all_packages:
                if pkg_info['name'].lower() in known_large_packages:
                    write_progress(pkg_info['name'], 'skipped_known_large', 0, pkg_info['category'], 
                                 "å·²çŸ¥å¤§åŒ…(>100MB)")
                    skipped_count += 1
                else:
                    filtered_packages.append(pkg_info)
            
            print(f"è·³è¿‡ {len(all_packages) - len(filtered_packages)} ä¸ªå·²çŸ¥å¤§åŒ…ï¼Œå‰©ä½™ {len(filtered_packages)} ä¸ªåŒ…")
            
            # é€ä¸ªä¸‹è½½åŒ…
            for i, package_info in enumerate(tqdm(filtered_packages, desc="ä¸‹è½½è¿›åº¦")):
                success, size_mb, package_dir = download_single_package(package_info, backup_dir, max_size_mb)
                
                if success:
                    success_count += 1
                    total_size += size_mb
                elif size_mb > 0:  # è·³è¿‡çš„å¤§æ–‡ä»¶
                    skipped_count += 1
                else:
                    failed_count += 1
                
                # æš‚åœä¸€ä¸‹ï¼Œé¿å…è¿‡äºé¢‘ç¹
                time.sleep(0.5)
            
            # å†™å…¥æœ€ç»ˆç»Ÿè®¡
            summary = {
                'total_packages': len(all_packages),
                'success_count': success_count,
                'failed_count': failed_count,
                'skipped_count': skipped_count,
                'total_size_mb': round(total_size, 2),
                'max_file_size_mb': max_size_mb,
                'completion_time': time.strftime('%Y-%m-%d %H:%M:%S')
            }
            
            with open('download_summary.json', 'w') as f:
                json.dump(summary, f, indent=2)
            
            print(f"\n=== ä¸‹è½½å®Œæˆ ===")
            print(f"âœ… æˆåŠŸ: {success_count}")
            print(f"âš ï¸ è·³è¿‡(>100MB): {skipped_count}")
            print(f"âŒ å¤±è´¥: {failed_count}")
            print(f"ğŸ’¾ æ€»å¤§å°: {total_size:.2f} MB")
            print(f"ğŸ“¦ å¤„ç†æ€»æ•°: {len(all_packages)}")
            
        if __name__ == '__main__':
            main()
        EOF
        
        # æµ‹è¯•Pythonè„šæœ¬è¯­æ³•
        echo "ğŸ§ª æµ‹è¯•Pythonè„šæœ¬è¯­æ³•..."
        python -m py_compile incremental_download.py
        if [ $? -eq 0 ]; then
            echo "âœ… Pythonè„šæœ¬è¯­æ³•æ­£ç¡®"
        else
            echo "âŒ Pythonè„šæœ¬è¯­æ³•é”™è¯¯"
            exit 1
        fi
        
        # åœ¨åå°è¿è¡Œä¸‹è½½è„šæœ¬
        echo "ğŸš€ å¼€å§‹é€ä¸ªä¸‹è½½PythonåŒ…..."
        python incremental_download.py classified_packages.yml Python_packages_backup $MAX_FILE_SIZE_MB &
        download_pid=$!
        
        # ç›‘æ§è¿›åº¦å¹¶é€ä¸€æäº¤
        echo "ğŸ”„ ç›‘æ§ä¸‹è½½è¿›åº¦å¹¶å®æ—¶æ¨é€..."
        last_progress=""
        commit_count=0
        
        while kill -0 $download_pid 2>/dev/null; do
          if [ -f "download_progress.txt" ]; then
            current_progress=$(cat download_progress.txt 2>/dev/null || echo "")
            
            if [ "$current_progress" != "$last_progress" ] && [ -n "$current_progress" ]; then
              package_name=$(echo "$current_progress" | cut -d'|' -f1)
              status=$(echo "$current_progress" | cut -d'|' -f2)
              size=$(echo "$current_progress" | cut -d'|' -f3)
              category=$(echo "$current_progress" | cut -d'|' -f4)
              reason=$(echo "$current_progress" | cut -d'|' -f5)
              
              echo "ğŸ“¦ åŒ…å¤„ç†å®Œæˆ: $package_name ($status, ${size}MB)"
              if [ -n "$reason" ]; then
                echo "   åŸå› : $reason"
              fi
              
              # å¦‚æœä¸‹è½½æˆåŠŸï¼Œç«‹å³æäº¤å¹¶æ¨é€
              if [ "$status" = "success" ]; then
                package_path="Python_packages_backup/${category}/${package_name}"
                
                if [ -d "$package_path" ]; then
                  echo "ğŸ’¾ æäº¤å¹¶æ¨é€ $package_name..."
                  
                  # æ·»åŠ æ–°ä¸‹è½½çš„åŒ…
                  git add "$package_path/"
                  
                  # æ·»åŠ è¿›åº¦æ–‡ä»¶
                  git add download_progress.txt 2>/dev/null || true
                  
                  # å°è¯•æäº¤
                  commit_msg="ğŸ“¦ Add ${package_name} (${size}MB) [${category}] - $(date +'%m-%d %H:%M')"
                  if git commit -m "$commit_msg"; then
                    echo "ğŸš€ æ¨é€ä¸­..."
                    
                    # æ¨é€é‡è¯•æœºåˆ¶
                    retry=0
                    while [ $retry -lt 3 ]; do
                      if git push origin main; then
                        echo "âœ… $package_name æ¨é€æˆåŠŸ"
                        commit_count=$((commit_count + 1))
                        break
                      else
                        retry=$((retry + 1))
                        echo "âš ï¸ æ¨é€å¤±è´¥ï¼Œé‡è¯• $retry/3..."
                        sleep $((retry * 2))
                      fi
                    done
                    
                    if [ $retry -eq 3 ]; then
                      echo "âŒ $package_name æ¨é€å¤±è´¥ï¼Œç»§ç»­ä¸‹ä¸€ä¸ª..."
                    fi
                  else
                    echo "âŒ $package_name æäº¤å¤±è´¥ï¼Œå¯èƒ½æ˜¯ç©ºæäº¤"
                  fi
                  
                  # æ¨é€æˆåŠŸåçŸ­æš‚æš‚åœï¼Œé¿å…GitHub APIé™åˆ¶
                  sleep 2
                else
                  echo "âš ï¸ åŒ…ç›®å½•ä¸å­˜åœ¨: $package_path"
                fi
              elif [[ "$status" == *"skipped"* ]]; then
                echo "âš ï¸ è·³è¿‡å¤§æ–‡ä»¶åŒ…: $package_name"
              fi
              
              last_progress="$current_progress"
            fi
          fi
          
          # æ¯3ç§’æ£€æŸ¥ä¸€æ¬¡ä¸‹è½½è¿›ç¨‹çŠ¶æ€
          sleep 3
        done
        
        # ç­‰å¾…ä¸‹è½½è„šæœ¬å®Œæˆ
        wait $download_pid
        echo "ğŸ‰ ä¸‹è½½è„šæœ¬æ‰§è¡Œå®Œæˆ"
        
        # æœ€ç»ˆæ¸…ç†å’Œæäº¤
        echo "ğŸ“Š æ‰§è¡Œæœ€ç»ˆæäº¤..."
        
        # æ·»åŠ å‰©ä½™æ–‡ä»¶
        git add Python_packages_backup/ 2>/dev/null || true
        git add download_summary.json 2>/dev/null || true
        
        if ! git diff --staged --quiet; then
          git commit -m "ğŸ“Š Final backup cleanup - $(date +'%Y-%m-%d %H:%M')" 2>/dev/null || true
          git push origin main 2>/dev/null || true
        fi
        
        echo "âœ… æ€»è®¡æäº¤äº† $commit_count ä¸ªæˆåŠŸçš„åŒ…"
        
    - name: Create metadata and reports
      env:
        PYTHON_VERSION: ${{ github.event.inputs.python_version || '3.12' }}
        GITHUB_EVENT_NAME: ${{ github.event_name }}
        GITHUB_RUN_ID: ${{ github.run_id }}
        GITHUB_REPOSITORY: ${{ github.repository }}
        PACKAGE_FILE: ${{ github.event.inputs.package_file || '.github/docs/lib_python.txt' }}
      run: |
        python .github/scripts/create_metadata.py \
          classified_packages.yml \
          Python_packages_backup
          
    - name: Show final summary
      if: always()
      run: |
        echo "## ğŸ“Š PythonåŒ…å¤‡ä»½ç»“æœ - $(date +'%Y-%m-%d %H:%M')" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        if [ -f "download_summary.json" ]; then
          # è¯»å–å¹¶æ˜¾ç¤ºç»Ÿè®¡ä¿¡æ¯
          python3 << 'EOF'
          import json
          
          try:
              with open('download_summary.json', 'r') as f:
                  summary = json.load(f)
              
              print(f"| âœ… æˆåŠŸ | {summary['success_count']} | å·²ä¸‹è½½å¹¶æ¨é€ |")
              print(f"| âš ï¸ è·³è¿‡(>100MB) | {summary['skipped_count']} | æ–‡ä»¶å¤§å°è¶…é™ |")
              print(f"| âŒ å¤±è´¥ | {summary['failed_count']} | ä¸‹è½½å¤±è´¥ |")
              print(f"| ğŸ“¦ æ€»æ•° | {summary['total_packages']} | è®¡åˆ’ä¸‹è½½ |")
              print(f"| ğŸ’¾ æ€»å¤§å° | {summary['total_size_mb']}MB | å®é™…æ¨é€æ•°æ® |")
              print(f"| â° å®Œæˆæ—¶é—´ | {summary['completion_time']} | å¤‡ä»½å®Œæˆæ—¶é—´ |")
          except Exception as e:
              print(f"âŒ æ— æ³•è¯»å–ç»Ÿè®¡ä¿¡æ¯: {e}")
          EOF >> $GITHUB_STEP_SUMMARY
        else
          echo "| çŠ¶æ€ | æ•°é‡ | å¤‡æ³¨ |" >> $GITHUB_STEP_SUMMARY
          echo "|------|------|------|" >> $GITHUB_STEP_SUMMARY
          echo "| âŒ æœªçŸ¥ | æœªçŸ¥ | ç»Ÿè®¡æ–‡ä»¶ä¸å­˜åœ¨ |" >> $GITHUB_STEP_SUMMARY
        fi
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ğŸ”§ æŠ€æœ¯ç»†èŠ‚" >> $GITHUB_STEP_SUMMARY
        echo "- è‡ªåŠ¨è·³è¿‡è¶…è¿‡100MBçš„æ–‡ä»¶" >> $GITHUB_STEP_SUMMARY
        echo "- é¢„æ£€æŸ¥å·²çŸ¥å¤§åŒ…(torch, tensorflowç­‰)" >> $GITHUB_STEP_SUMMARY
        echo "- é€ä¸ªä¸‹è½½æ¨é€ï¼Œé¿å…æ–‡ä»¶ç´¯ç§¯" >> $GITHUB_STEP_SUMMARY
        echo "- è‡ªåŠ¨é‡è¯•æ¨é€å¤±è´¥çš„æƒ…å†µ" >> $GITHUB_STEP_SUMMARY
        echo "- å®æ—¶ç›‘æ§ä¸‹è½½è¿›åº¦" >> $GITHUB_STEP_SUMMARY
        
        # æ˜¾ç¤ºå®é™…å¤‡ä»½æƒ…å†µ
        if [ -d "Python_packages_backup" ]; then
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ“ å¤‡ä»½ç›®å½•çŠ¶æ€" >> $GITHUB_STEP_SUMMARY
          echo "- åˆ†ç±»ç›®å½•æ•°: $(find Python_packages_backup -maxdepth 1 -type d | wc -l)" >> $GITHUB_STEP_SUMMARY
          echo "- åŒ…ç›®å½•æ•°: $(find Python_packages_backup -mindepth 2 -maxdepth 2 -type d | wc -l)" >> $GITHUB_STEP_SUMMARY
          echo "- æ–‡ä»¶æ€»æ•°: $(find Python_packages_backup -type f | wc -l)" >> $GITHUB_STEP_SUMMARY
          echo "- ç£ç›˜ä½¿ç”¨: $(du -sh Python_packages_backup 2>/dev/null | cut -f1 || echo 'æœªçŸ¥')" >> $GITHUB_STEP_SUMMARY
        fi
        
        # æ˜¾ç¤ºè·³è¿‡çš„å¤§æ–‡ä»¶åŒ…åˆ—è¡¨
        if [ -f "download_progress.txt" ]; then
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### âš ï¸ è·³è¿‡çš„å¤§æ–‡ä»¶åŒ… (>100MB)" >> $GITHUB_STEP_SUMMARY
          echo "| åŒ…å | åŸå›  |" >> $GITHUB_STEP_SUMMARY
          echo "|------|------|" >> $GITHUB_STEP_SUMMARY
          
          python3 << 'EOF'
          import re
          
          try:
              with open('download_progress.txt', 'r') as f:
                  content = f.read().strip()
                  if content:
                      parts = content.split('|')
                      if len(parts) >= 5:
                          package_name = parts[0]
                          status = parts[1]
                          reason = parts[4]
                          if 'skipped' in status or 'known_large' in status:
                              print(f"| {package_name} | {reason} |")
          except:
              pass
          EOF >> $GITHUB_STEP_SUMMARY
        fi
        
    - name: Create release (manual only)
      if: github.event_name == 'workflow_dispatch'
      uses: softprops/action-gh-release@v1
      with:
        tag_name: python-packages-$(date +'%Y%m%d-%H%M')
        name: Python Packages Backup $(date +'%Y-%m-%d %H:%M')
        body_path: Python_packages_backup/download_report.md
        files: |
          Python_packages_backup/**/*
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
