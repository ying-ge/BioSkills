name: Backup GitHub R Packages (One by One - Fixed)
 
on:
  workflow_dispatch:
  schedule:
    - cron: "0 2 * * 0"
 
permissions:
  contents: write
  actions: read
 
jobs:
  backup-packages:
    runs-on: ubuntu-latest
    
    env:
      GITHUB_PAT: ${{ secrets.GITHUB_TOKEN }}
 
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0
 
    - name: Set up R
      uses: r-lib/actions/setup-r@v2
      with:
        r-version: "4.3"
        use-public-rspm: true
 
    - name: Install R dependencies
      uses: r-lib/actions/setup-r-dependencies@v2
      with:
        packages: |
          any::jsonlite
          any::httr
        cache-version: 2
 
    - name: Configure Git
      run: |
        git config --global user.name "GitHub Actions Bot"
        git config --global user.email "actions@github.com"
 
    # é¦–å…ˆæ£€æŸ¥å¹¶åˆ›å»ºä»“åº“åˆ—è¡¨æ–‡ä»¶ï¼ˆå¦‚æžœä¸å­˜åœ¨ï¼‰
    - name: Check and create repository list
      run: |
        echo "ðŸ” æ£€æŸ¥ä»“åº“åˆ—è¡¨æ–‡ä»¶..."
        
        # æ£€æŸ¥å¯èƒ½çš„æ–‡ä»¶ä½ç½®
        if [ -f ".github/docs/github_library.txt" ]; then
          echo "âœ… æ‰¾åˆ°æ–‡ä»¶: .github/docs/github_library.txt"
          cp .github/docs/github_library.txt github_library.txt
        elif [ -f "docs/github_library.txt" ]; then
          echo "âœ… æ‰¾åˆ°æ–‡ä»¶: docs/github_library.txt"
          cp docs/github_library.txt github_library.txt
        elif [ -f "github_library.txt" ]; then
          echo "âœ… æ‰¾åˆ°æ–‡ä»¶: github_library.txt"
        elif [ -f "scripts/github_library.txt" ]; then
          echo "âœ… æ‰¾åˆ°æ–‡ä»¶: scripts/github_library.txt"
          cp scripts/github_library.txt github_library.txt
        else
          echo "âš ï¸ æœªæ‰¾åˆ°ä»“åº“åˆ—è¡¨æ–‡ä»¶ï¼Œåˆ›å»ºç¤ºä¾‹æ–‡ä»¶..."
          cat > github_library.txt << 'EOF'
        # GitHub RåŒ…ä»“åº“åˆ—è¡¨
        tpq/kpmt
        cBioPortal/cgdsr
        satijalab/seurat-data
        jespermaag/gganatogram
        chrisamiller/fishplot
        BITS-VIB/venn-tools
        GuangchuangYu/gglayer
        IOBR/IOBR
        IndrajeetPatil/ggstatsplot
        KrishnaswamyLab/MAGIC
        NKI-CCB/DISCOVER
        Simon-Coetzee/motifBreakR
        ebecht/MCPcounter
        fawda123/ggord
        nicholasehamilton/ggtern
        paulgeeleher/pRRophetic
        ropensci/rentrez
        xlucpu/MOVICS
        zzwch/crosslink
        EOF
          echo "âœ… å·²åˆ›å»ºç¤ºä¾‹æ–‡ä»¶ github_library.txt"
        fi
        
        echo "ðŸ“„ æ–‡ä»¶å†…å®¹é¢„è§ˆ:"
        head -10 github_library.txt
 
    - name: Create and run backup script
      run: |
        cat > backup_one_by_one.R << 'EOF'
        library(jsonlite)
        library(httr)
        
        github_token <- Sys.getenv("GITHUB_PAT")
        if (github_token != "") {
          httr::set_config(httr::add_headers(Authorization = paste("token", github_token)))
        }
        
        # è¯»å–ä»“åº“åˆ—è¡¨
        read_github_repos <- function(file_path) {
          if (!file.exists(file_path)) {
            stop(paste("æ–‡ä»¶ä¸å­˜åœ¨:", file_path))
          }
          
          lines <- readLines(file_path, warn = FALSE)
          lines <- lines[lines != "" & !grepl("^#", lines)]
          
          repos <- character(0)
          for (line in lines) {
            line <- trimws(line)
            if (grepl("github.com", line)) {
              repo <- gsub(".*github.com/([^/]+/[^/]+).*", "\\1", line)
              repos <- c(repos, repo)
            } else if (grepl("^[^/]+/[^/]+$", line)) {
              repos <- c(repos, line)
            }
          }
          
          return(unique(repos))
        }
        
        # å•ä¸ªä»“åº“å¤‡ä»½å‡½æ•°
        backup_single_repo <- function(repo, backup_dir = "R_packages_backup", max_file_size_mb = 100) {
          repo_name <- gsub("/", "_", repo)
          repo_dir <- file.path(backup_dir, repo_name)
          
          # æ¸…ç†å¯èƒ½å­˜åœ¨çš„æ—§ç›®å½•
          if (dir.exists(repo_dir)) {
            unlink(repo_dir, recursive = TRUE)
          }
          
          if (!dir.exists(backup_dir)) {
            dir.create(backup_dir, recursive = TRUE)
          }
          dir.create(repo_dir)
          
          cat("ðŸ”„ æ­£åœ¨å¤‡ä»½:", repo, "\n")
          
          result <- list(
            repo = repo,
            status = "failed",
            download_date = as.character(Sys.Date()),
            file_size_mb = 0,
            commit_hash = ""
          )
          
          tryCatch({
            # å°è¯•ä¸‹è½½ä¸»åˆ†æ”¯
            zip_urls <- c(
              paste0("https://github.com/", repo, "/archive/refs/heads/master.zip"),
              paste0("https://github.com/", repo, "/archive/refs/heads/main.zip")
            )
            
            downloaded <- FALSE
            final_file <- NULL
            
            for (j in seq_along(zip_urls)) {
              branch_name <- c("master", "main")[j]
              zip_file <- file.path(repo_dir, paste0(repo_name, "_", branch_name, ".zip"))
              
              tryCatch({
                download.file(zip_urls[j], zip_file, mode = "wb", quiet = TRUE)
                if (file.exists(zip_file) && file.size(zip_file) > 1000) {
                  file_size_mb <- file.size(zip_file) / (1024^2)
                  
                  if (file_size_mb > max_file_size_mb) {
                    cat(sprintf("âš ï¸ æ–‡ä»¶è¿‡å¤§ (%.1f MB > %d MB)ï¼Œè·³è¿‡\n", file_size_mb, max_file_size_mb))
                    result$status <- sprintf("skipped - too large (%.1f MB)", file_size_mb)
                    result$file_size_mb <- file_size_mb
                    file.remove(zip_file)
                    return(result)
                  }
                  
                  downloaded <- TRUE
                  final_file <- zip_file
                  result$file_size_mb <- round(file_size_mb, 2)
                  break
                } else if (file.exists(zip_file)) {
                  file.remove(zip_file)
                }
              }, error = function(e) NULL)
            }
            
            if (downloaded) {
              # èŽ·å–ä»“åº“ä¿¡æ¯
              if (github_token != "") {
                api_url <- paste0("https://api.github.com/repos/", repo)
                tryCatch({
                  response <- httr::GET(api_url)
                  if (httr::status_code(response) == 200) {
                    repo_info <- httr::content(response, "text", encoding = "UTF-8")
                    meta_file <- file.path(repo_dir, "repository_info.json")
                    writeLines(repo_info, meta_file)
                    
                    # æå–é»˜è®¤åˆ†æ”¯ä¿¡æ¯
                    repo_data <- fromJSON(repo_info)
                    if (!is.null(repo_data$default_branch)) {
                      result$commit_hash <- repo_data$default_branch
                    }
                  }
                }, error = function(e) NULL)
              }
              
              result$status <- "success"
              cat(sprintf("âœ… ä¸‹è½½æˆåŠŸ (%.1f MB)\n", result$file_size_mb))
            } else {
              result$status <- "failed - no accessible branch"
              cat("âŒ ä¸‹è½½å¤±è´¥\n")
              unlink(repo_dir, recursive = TRUE)
            }
            
          }, error = function(e) {
            result$status <- paste("error:", e$message)
            cat("âŒ å‡ºé”™:", e$message, "\n")
            unlink(repo_dir, recursive = TRUE)
          })
          
          return(result)
        }
        
        # å›ºå®šä½¿ç”¨æ ¹ç›®å½•çš„æ–‡ä»¶
        repo_file <- "github_library.txt"
        
        if (!file.exists(repo_file)) {
          cat("é”™è¯¯: æœªæ‰¾åˆ°ä»“åº“åˆ—è¡¨æ–‡ä»¶", repo_file, "\n")
          quit(status = 1)
        }
        
        # è¯»å–ä»“åº“åˆ—è¡¨
        github_repos <- read_github_repos(repo_file)
        cat("æ‰¾åˆ°", length(github_repos), "ä¸ªä»“åº“ï¼Œå°†é€ä¸€å¤„ç†\n\n")
        
        if (length(github_repos) == 0) {
          cat("é”™è¯¯: ä»“åº“åˆ—è¡¨ä¸ºç©º\n")
          quit(status = 1)
        }
        
        # åˆ›å»ºæ€»æ—¥å¿—
        all_results <- data.frame(
          repo = character(),
          status = character(),
          download_date = character(),
          file_size_mb = numeric(),
          commit_hash = character(),
          stringsAsFactors = FALSE
        )
        
        # é€ä¸€å¤„ç†æ¯ä¸ªä»“åº“
        for (i in seq_along(github_repos)) {
          repo <- github_repos[i]
          cat(sprintf("\n=== [%d/%d] å¤„ç†ä»“åº“: %s ===\n", i, length(github_repos), repo))
          
          # å¤‡ä»½å•ä¸ªä»“åº“
          result <- backup_single_repo(repo, max_file_size_mb = 100)
          
          # è®°å½•ç»“æžœ
          all_results <- rbind(all_results, data.frame(
            repo = result$repo,
            status = result$status,
            download_date = result$download_date,
            file_size_mb = result$file_size_mb,
            commit_hash = result$commit_hash,
            stringsAsFactors = FALSE
          ))
          
          # ä¿å­˜å½“å‰çŠ¶æ€çš„æ—¥å¿—
          backup_dir <- "R_packages_backup"
          if (!dir.exists(backup_dir)) {
            dir.create(backup_dir, recursive = TRUE)
          }
          
          log_file <- file.path(backup_dir, paste0("backup_log_", Sys.Date(), ".csv"))
          write.csv(all_results, log_file, row.names = FALSE)
          
          # è¾“å‡ºå½“å‰ä»“åº“çš„å¤„ç†ç»“æžœ
          result_line <- paste(result$repo, result$status, result$file_size_mb, sep = "|")
          writeLines(result_line, "current_result.txt")
          
          cat(sprintf("ðŸ“Š å½“å‰è¿›åº¦: %d/%d å®Œæˆ\n", i, length(github_repos)))
          
          # é¿å…APIé™åˆ¶
          if (i %% 5 == 0) {
            Sys.sleep(2)
          }
        }
        
        # æœ€ç»ˆç»Ÿè®¡
        success_count <- sum(all_results$status == "success")
        skipped_count <- sum(grepl("too large", all_results$status))
        failed_count <- nrow(all_results) - success_count - skipped_count
        total_size_mb <- sum(all_results$file_size_mb[all_results$status == "success"])
        
        cat("\n\n=== æœ€ç»ˆç»Ÿè®¡ ===\n")
        cat("æ€»æ•°:", nrow(all_results), "\n")
        cat("æˆåŠŸ:", success_count, sprintf("(%.1f MB)", total_size_mb), "\n")
        cat("è·³è¿‡(è¿‡å¤§):", skipped_count, "\n")
        cat("å¤±è´¥:", failed_count, "\n")
        
        # è¾“å‡ºæœ€ç»ˆç»Ÿè®¡
        final_stats <- paste(success_count, skipped_count, failed_count, round(total_size_mb, 1), sep = "|")
        writeLines(final_stats, "final_stats.txt")
        EOF
        
        # è¿è¡ŒRè„šæœ¬
        echo "ðŸš€ å¼€å§‹è¿è¡Œå¤‡ä»½è„šæœ¬..."
        Rscript backup_one_by_one.R &
        r_pid=$!
        
        # ç›‘æŽ§è¿›åº¦å¹¶é€ä¸€æäº¤
        echo "ðŸ”„ å¼€å§‹ç›‘æŽ§è¿›åº¦..."
        repo_count=0
        last_result=""
        
        while kill -0 $r_pid 2>/dev/null; do
          if [ -f "current_result.txt" ]; then
            current_result=$(cat current_result.txt 2>/dev/null || echo "")
            
            # æ£€æŸ¥æ˜¯å¦æ˜¯æ–°çš„ç»“æžœ
            if [ "$current_result" != "$last_result" ] && [ -n "$current_result" ]; then
              repo_name=$(echo "$current_result" | cut -d'|' -f1)
              status=$(echo "$current_result" | cut -d'|' -f2)
              file_size=$(echo "$current_result" | cut -d'|' -f3)
              
              repo_dir_name=$(echo "$repo_name" | sed 's/\//_/g')
              
              echo ""
              echo "ðŸ“¦ å¤„ç†å®Œæˆ: $repo_name ($status)"
              
              # æäº¤è¿™ä¸ªä»“åº“çš„å¤‡ä»½
              if [ "$status" = "success" ] && [ -d "R_packages_backup/$repo_dir_name" ]; then
                echo "ðŸ’¾ æäº¤ $repo_name çš„å¤‡ä»½..."
                
                git add "R_packages_backup/$repo_dir_name/"
                git add "R_packages_backup/backup_log_$(date +'%Y-%m-%d').csv" 2>/dev/null || true
                
                if ! git diff --staged --quiet; then
                  if git commit -m "ðŸ“¦ Add backup for $repo_name (${file_size}MB) - $(date +'%Y-%m-%d %H:%M')"; then
                    echo "ðŸš€ æŽ¨é€ä¸­..."
                    
                    retry=0
                    while [ $retry -lt 3 ]; do
                      if git push origin main; then
                        echo "âœ… $repo_name æŽ¨é€æˆåŠŸ"
                        break
                      else
                        retry=$((retry + 1))
                        echo "âš ï¸ æŽ¨é€å¤±è´¥ï¼Œé‡è¯• $retry/3..."
                        sleep $((retry * 2))
                      fi
                    done
                    
                    if [ $retry -eq 3 ]; then
                      echo "âŒ $repo_name æŽ¨é€å¤±è´¥"
                    fi
                  else
                    echo "âŒ $repo_name æäº¤å¤±è´¥"
                  fi
                fi
              else
                echo "â„¹ï¸ $repo_name çŠ¶æ€: $statusï¼Œæ›´æ–°æ—¥å¿—"
                git add "R_packages_backup/backup_log_$(date +'%Y-%m-%d').csv" 2>/dev/null || true
                git commit -m "ðŸ“Š Update log for $repo_name ($status)" 2>/dev/null || true
                git push origin main 2>/dev/null || true
              fi
              
              last_result="$current_result"
              repo_count=$((repo_count + 1))
            fi
          fi
          
          sleep 3
        done
        
        # ç­‰å¾…Rè„šæœ¬å®Œæˆ
        wait $r_pid
        echo ""
        echo "ðŸŽ‰ Rè„šæœ¬æ‰§è¡Œå®Œæˆï¼"
        
        # æœ€ç»ˆæäº¤
        if [ -f "final_stats.txt" ]; then
          stats=$(cat final_stats.txt)
          success=$(echo "$stats" | cut -d'|' -f1)
          skipped=$(echo "$stats" | cut -d'|' -f2) 
          failed=$(echo "$stats" | cut -d'|' -f3)
          total_size=$(echo "$stats" | cut -d'|' -f4)
          
          echo "ðŸ“Š æœ€ç»ˆç»Ÿè®¡: æˆåŠŸ $success, è·³è¿‡ $skipped, å¤±è´¥ $failed, æ€»å¤§å° ${total_size}MB"
          
          git add "R_packages_backup/" 2>/dev/null || true
          git commit -m "ðŸ“Š Final backup summary: $success success, $skipped skipped, $failed failed - $(date +'%Y-%m-%d')" 2>/dev/null || true
          git push origin main 2>/dev/null || true
        fi
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
 
    - name: Create summary
      if: always()
      run: |
        if [ -f "final_stats.txt" ]; then
          stats=$(cat final_stats.txt)
          success=$(echo "$stats" | cut -d'|' -f1)
          skipped=$(echo "$stats" | cut -d'|' -f2) 
          failed=$(echo "$stats" | cut -d'|' -f3)
          total_size=$(echo "$stats" | cut -d'|' -f4)
          total=$((success + skipped + failed))
          
          echo "## ðŸ“Š é€ä¸€å¤‡ä»½å®Œæˆ - $(date +'%Y-%m-%d')" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| çŠ¶æ€ | æ•°é‡ | è¯´æ˜Ž |" >> $GITHUB_STEP_SUMMARY
          echo "|------|------|------|" >> $GITHUB_STEP_SUMMARY
          echo "| âœ… æˆåŠŸ | $success | å·²å¤‡ä»½å¹¶æŽ¨é€ |" >> $GITHUB_STEP_SUMMARY
          echo "| âš ï¸ è·³è¿‡ | $skipped | æ–‡ä»¶è¿‡å¤§(>100MB) |" >> $GITHUB_STEP_SUMMARY
          echo "| âŒ å¤±è´¥ | $failed | ä¸‹è½½å¤±è´¥ |" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸ“¦ æ€»è®¡ | $total | - |" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸ’¾ æ€»å¤§å° | ${total_size}MB | å·²æŽ¨é€æ•°æ® |" >> $GITHUB_STEP_SUMMARY
        else
          echo "## âš ï¸ å¤‡ä»½æœªå®Œæˆ" >> $GITHUB_STEP_SUMMARY
          echo "æœªæ‰¾åˆ°ç»Ÿè®¡æ–‡ä»¶ï¼Œè¯·æ£€æŸ¥æ—¥å¿—" >> $GITHUB_STEP_SUMMARY
        fi
