name: Backup GitHub R Packages (One by One)
 
on:
  workflow_dispatch:
  #schedule:
  #  - cron: "0 2 * * 0"
 
permissions:
  contents: write
  actions: read
 
jobs:
  backup-packages:
    runs-on: ubuntu-latest
    
    env:
      GITHUB_PAT: ${{ secrets.GITHUB_TOKEN }}
 
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0
 
    - name: Set up R
      uses: r-lib/actions/setup-r@v2
      with:
        r-version: "4.3"
        use-public-rspm: true
 
    - name: Install R dependencies
      uses: r-lib/actions/setup-r-dependencies@v2
      with:
        packages: |
          any::jsonlite
          any::httr
        cache-version: 2
 
    - name: Configure Git
      run: |
        git config --global user.name "GitHub Actions Bot"
        git config --global user.email "actions@github.com"
 
    - name: Create and run one-by-one backup script
      run: |
        cat > backup_one_by_one.R << 'EOF'
        library(jsonlite)
        library(httr)
        
        github_token <- Sys.getenv("GITHUB_PAT")
        if (github_token != "") {
          httr::set_config(httr::add_headers(Authorization = paste("token", github_token)))
        }
        
        # è¯»å–ä»“åº“åˆ—è¡¨
        read_github_repos <- function(file_path) {
          if (!file.exists(file_path)) {
            stop("æ–‡ä»¶ä¸å­˜åœ¨: ", file_path)
          }
          
          lines <- readLines(file_path, warn = FALSE)
          lines <- lines[lines != "" & !grepl("^#", lines)]
          
          repos <- character(0)
          for (line in lines) {
            if (grepl("github.com", line)) {
              repo <- gsub(".*github.com/([^/]+/[^/]+).*", "\\1", line)
              repos <- c(repos, repo)
            } else if (grepl("^[^/]+/[^/]+$", trimws(line))) {
              repos <- c(repos, trimws(line))
            }
          }
          
          return(unique(repos))
        }
        
        # å•ä¸ªä»“åº“å¤‡ä»½å‡½æ•°
        backup_single_repo <- function(repo, backup_dir = "R_packages_backup", max_file_size_mb = 100) {
          repo_name <- gsub("/", "_", repo)
          repo_dir <- file.path(backup_dir, repo_name)
          
          # æ¸…ç†å¯èƒ½å­˜åœ¨çš„æ—§ç›®å½•
          if (dir.exists(repo_dir)) {
            unlink(repo_dir, recursive = TRUE)
          }
          
          if (!dir.exists(backup_dir)) {
            dir.create(backup_dir, recursive = TRUE)
          }
          dir.create(repo_dir)
          
          cat("ðŸ”„ æ­£åœ¨å¤‡ä»½:", repo, "\n")
          
          result <- list(
            repo = repo,
            status = "failed",
            download_date = as.character(Sys.Date()),
            file_size_mb = 0,
            commit_hash = NA
          )
          
          tryCatch({
            # å°è¯•ä¸‹è½½ä¸»åˆ†æ”¯
            zip_urls <- c(
              paste0("https://github.com/", repo, "/archive/refs/heads/master.zip"),
              paste0("https://github.com/", repo, "/archive/refs/heads/main.zip")
            )
            
            downloaded <- FALSE
            final_file <- NULL
            
            for (j in seq_along(zip_urls)) {
              branch_name <- c("master", "main")[j]
              zip_file <- file.path(repo_dir, paste0(repo_name, "_", branch_name, ".zip"))
              
              tryCatch({
                download.file(zip_urls[j], zip_file, mode = "wb", quiet = TRUE)
                if (file.exists(zip_file) && file.size(zip_file) > 1000) {
                  file_size_mb <- file.size(zip_file) / (1024^2)
                  
                  if (file_size_mb > max_file_size_mb) {
                    cat(sprintf("âš ï¸ æ–‡ä»¶è¿‡å¤§ (%.1f MB > %d MB)ï¼Œè·³è¿‡\n", file_size_mb, max_file_size_mb))
                    result$status <- sprintf("skipped - too large (%.1f MB)", file_size_mb)
                    result$file_size_mb <- file_size_mb
                    file.remove(zip_file)
                    return(result)
                  }
                  
                  downloaded <- TRUE
                  final_file <- zip_file
                  result$file_size_mb <- round(file_size_mb, 2)
                  break
                } else if (file.exists(zip_file)) {
                  file.remove(zip_file)
                }
              }, error = function(e) NULL)
            }
            
            if (downloaded) {
              # èŽ·å–ä»“åº“ä¿¡æ¯
              if (github_token != "") {
                api_url <- paste0("https://api.github.com/repos/", repo)
                tryCatch({
                  response <- httr::GET(api_url)
                  if (httr::status_code(response) == 200) {
                    repo_info <- httr::content(response, "text", encoding = "UTF-8")
                    meta_file <- file.path(repo_dir, "repository_info.json")
                    writeLines(repo_info, meta_file)
                    
                    # æå–commit hash
                    repo_data <- fromJSON(repo_info)
                    if (!is.null(repo_data$default_branch)) {
                      result$commit_hash <- repo_data$default_branch
                    }
                  }
                }, error = function(e) NULL)
              }
              
              result$status <- "success"
              cat(sprintf("âœ… ä¸‹è½½æˆåŠŸ (%.1f MB)\n", result$file_size_mb))
            } else {
              result$status <- "failed - no accessible branch"
              cat("âŒ ä¸‹è½½å¤±è´¥\n")
              unlink(repo_dir, recursive = TRUE)
            }
            
          }, error = function(e) {
            result$status <- paste("error:", e$message)
            cat("âŒ å‡ºé”™:", e$message, "\n")
            unlink(repo_dir, recursive = TRUE)
          })
          
          return(result)
        }
        
        # æŸ¥æ‰¾ä»“åº“åˆ—è¡¨æ–‡ä»¶
        possible_paths <- c(
          ".github/docs/github_library.txt",
        )
        
        repo_file <- NULL
        for (path in possible_paths) {
          if (file.exists(path)) {
            repo_file <- path
            break
          }
        }
        
        if (is.null(repo_file)) {
          cat("æœªæ‰¾åˆ°ä»“åº“åˆ—è¡¨æ–‡ä»¶\n")
          quit(status = 1)
        }
        
        # è¯»å–ä»“åº“åˆ—è¡¨
        github_repos <- read_github_repos(repo_file)
        cat("æ‰¾åˆ°", length(github_repos), "ä¸ªä»“åº“ï¼Œå°†é€ä¸€å¤„ç†\n\n")
        
        # åˆ›å»ºæ€»æ—¥å¿—
        all_results <- data.frame(
          repo = character(),
          status = character(),
          download_date = character(),
          file_size_mb = numeric(),
          commit_hash = character(),
          stringsAsFactors = FALSE
        )
        
        # é€ä¸€å¤„ç†æ¯ä¸ªä»“åº“
        for (i in seq_along(github_repos)) {
          repo <- github_repos[i]
          cat(sprintf("\n=== [%d/%d] å¤„ç†ä»“åº“: %s ===\n", i, length(github_repos), repo))
          
          # å¤‡ä»½å•ä¸ªä»“åº“
          result <- backup_single_repo(repo, max_file_size_mb = 100)
          
          # è®°å½•ç»“æžœ
          all_results <- rbind(all_results, data.frame(
            repo = result$repo,
            status = result$status,
            download_date = result$download_date,
            file_size_mb = result$file_size_mb,
            commit_hash = ifelse(is.na(result$commit_hash), "", result$commit_hash),
            stringsAsFactors = FALSE
          ))
          
          # ä¿å­˜å½“å‰çŠ¶æ€çš„æ—¥å¿—
          backup_dir <- "R_packages_backup"
          if (!dir.exists(backup_dir)) {
            dir.create(backup_dir, recursive = TRUE)
          }
          
          log_file <- file.path(backup_dir, paste0("backup_log_", Sys.Date(), ".csv"))
          write.csv(all_results, log_file, row.names = FALSE)
          
          # è¾“å‡ºå½“å‰ä»“åº“çš„å¤„ç†ç»“æžœæ–‡ä»¶ï¼Œä¾›shellè„šæœ¬è¯»å–
          cat(paste(result$repo, result$status, result$file_size_mb, sep = "|"), file = "current_result.txt")
          
          cat(sprintf("ðŸ“Š å½“å‰è¿›åº¦: %d/%d å®Œæˆ\n", i, length(github_repos)))
          
          # é¿å…APIé™åˆ¶
          if (i %% 5 == 0) {
            Sys.sleep(2)
          }
        }
        
        # æœ€ç»ˆç»Ÿè®¡
        success_count <- sum(all_results$status == "success")
        skipped_count <- sum(grepl("too large", all_results$status))
        failed_count <- nrow(all_results) - success_count - skipped_count
        total_size_mb <- sum(all_results$file_size_mb[all_results$status == "success"])
        
        cat("\n\n=== æœ€ç»ˆç»Ÿè®¡ ===\n")
        cat("æ€»æ•°:", nrow(all_results), "\n")
        cat("æˆåŠŸ:", success_count, sprintf("(%.1f MB)", total_size_mb), "\n")
        cat("è·³è¿‡(è¿‡å¤§):", skipped_count, "\n")
        cat("å¤±è´¥:", failed_count, "\n")
        
        # è¾“å‡ºæœ€ç»ˆç»Ÿè®¡
        cat(paste(success_count, skipped_count, failed_count, total_size_mb, sep = "|"), file = "final_stats.txt")
        EOF
        
        # è¿è¡ŒRè„šæœ¬ï¼Œé€ä¸€å¤„ç†ä»“åº“
        Rscript backup_one_by_one.R &
        r_pid=$!
        
        # ç›‘æŽ§Rè„šæœ¬è¿›åº¦å¹¶é€ä¸€æäº¤
        repo_count=0
        while kill -0 $r_pid 2>/dev/null; do
          # æ£€æŸ¥æ˜¯å¦æœ‰æ–°çš„ä»“åº“å¤„ç†å®Œæˆ
          if [ -f "current_result.txt" ]; then
            result_line=$(cat current_result.txt)
            repo_name=$(echo "$result_line" | cut -d'|' -f1)
            status=$(echo "$result_line" | cut -d'|' -f2)
            file_size=$(echo "$result_line" | cut -d'|' -f3)
            
            repo_dir_name=$(echo "$repo_name" | sed 's/\//_/g')
            
            echo ""
            echo "ðŸ”„ å¤„ç†å®Œæˆ: $repo_name ($status)"
            
            # æäº¤è¿™ä¸ªä»“åº“çš„å¤‡ä»½ï¼ˆå¦‚æžœæˆåŠŸï¼‰
            if [ "$status" = "success" ] && [ -d "R_packages_backup/$repo_dir_name" ]; then
              echo "ðŸ“¦ æäº¤ $repo_name çš„å¤‡ä»½æ–‡ä»¶..."
              
              git add "R_packages_backup/$repo_dir_name/"
              git add "R_packages_backup/backup_log_$(date +'%Y-%m-%d').csv"
              
              if ! git diff --staged --quiet; then
                if git commit -m "ðŸ“¦ Add backup for $repo_name (${file_size}MB) - $(date +'%Y-%m-%d %H:%M')"; then
                  echo "ðŸ’¾ æäº¤æˆåŠŸï¼Œæ­£åœ¨æŽ¨é€..."
                  
                  # æŽ¨é€ï¼Œå¸¦é‡è¯•
                  retry=0
                  while [ $retry -lt 3 ]; do
                    if git push origin main; then
                      echo "âœ… $repo_name æŽ¨é€æˆåŠŸ"
                      break
                    else
                      retry=$((retry + 1))
                      echo "âš ï¸ æŽ¨é€å¤±è´¥ï¼Œé‡è¯• $retry/3..."
                      sleep 5
                    fi
                  done
                  
                  if [ $retry -eq 3 ]; then
                    echo "âŒ $repo_name æŽ¨é€å¤±è´¥"
                  fi
                else
                  echo "âŒ $repo_name æäº¤å¤±è´¥"
                fi
              fi
            elif [ "$status" != "success" ]; then
              echo "âš ï¸ $repo_name æœªæˆåŠŸä¸‹è½½ï¼Œè·³è¿‡æäº¤"
              # ä»ç„¶æäº¤æ›´æ–°çš„æ—¥å¿—
              git add "R_packages_backup/backup_log_$(date +'%Y-%m-%d').csv" 2>/dev/null || true
              git commit -m "ðŸ“Š Update log for $repo_name ($status) - $(date +'%Y-%m-%d %H:%M')" 2>/dev/null || true
              git push origin main 2>/dev/null || true
            fi
            
            # æ¸…ç†å½“å‰ç»“æžœæ–‡ä»¶ï¼Œå‡†å¤‡ä¸‹ä¸€æ¬¡
            rm -f current_result.txt
            repo_count=$((repo_count + 1))
          fi
          
          sleep 3
        done
        
        # ç­‰å¾…Rè„šæœ¬å®Œæˆ
        wait $r_pid
        
        echo ""
        echo "ðŸŽ‰ æ‰€æœ‰ä»“åº“å¤„ç†å®Œæˆï¼"
        
        # æœ€ç»ˆç»Ÿè®¡æäº¤
        if [ -f "final_stats.txt" ]; then
          stats=$(cat final_stats.txt)
          success=$(echo "$stats" | cut -d'|' -f1)
          skipped=$(echo "$stats" | cut -d'|' -f2) 
          failed=$(echo "$stats" | cut -d'|' -f3)
          total_size=$(echo "$stats" | cut -d'|' -f4)
          
          echo "ðŸ“Š æœ€ç»ˆç»Ÿè®¡: æˆåŠŸ $success, è·³è¿‡ $skipped, å¤±è´¥ $failed, æ€»å¤§å° ${total_size}MB"
          
          # ç¡®ä¿æœ€ç»ˆæ—¥å¿—è¢«æäº¤
          git add "R_packages_backup/backup_log_$(date +'%Y-%m-%d').csv" 2>/dev/null || true
          git commit -m "ðŸ“Š Final backup summary: $success success, $skipped skipped, $failed failed - $(date +'%Y-%m-%d')" 2>/dev/null || true
          git push origin main 2>/dev/null || true
        fi
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
 
    - name: Create summary
      if: always()
      run: |
        if [ -f "final_stats.txt" ]; then
          stats=$(cat final_stats.txt)
          success=$(echo "$stats" | cut -d'|' -f1)
          skipped=$(echo "$stats" | cut -d'|' -f2) 
          failed=$(echo "$stats" | cut -d'|' -f3)
          total_size=$(echo "$stats" | cut -d'|' -f4)
          total=$((success + skipped + failed))
          
          echo "## ðŸ“Š é€ä¸€å¤‡ä»½å®Œæˆ - $(date +'%Y-%m-%d')" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| çŠ¶æ€ | æ•°é‡ | è¯´æ˜Ž |" >> $GITHUB_STEP_SUMMARY
          echo "|------|------|------|" >> $GITHUB_STEP_SUMMARY
          echo "| âœ… æˆåŠŸ | $success | å·²å¤‡ä»½å¹¶æŽ¨é€ |" >> $GITHUB_STEP_SUMMARY
          echo "| âš ï¸ è·³è¿‡ | $skipped | æ–‡ä»¶è¿‡å¤§(>100MB) |" >> $GITHUB_STEP_SUMMARY
          echo "| âŒ å¤±è´¥ | $failed | ä¸‹è½½å¤±è´¥ |" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸ“¦ æ€»è®¡ | $total | - |" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸ’¾ æ€»å¤§å° | ${total_size}MB | å·²æŽ¨é€æ•°æ® |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### âœ¨ ç‰¹ç‚¹" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ”„ é€ä¸€å¤„ç†: æ¯ä¸ªä»“åº“ç‹¬ç«‹ä¸‹è½½å’ŒæŽ¨é€" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ“¦ å³æ—¶æŽ¨é€: ä¸‹è½½å®Œæˆç«‹å³æŽ¨é€ï¼Œé¿å…ç´¯ç§¯" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ›¡ï¸ å¤§å°é™åˆ¶: è¶…è¿‡100MBçš„æ–‡ä»¶è‡ªåŠ¨è·³è¿‡" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ” é‡è¯•æœºåˆ¶: æŽ¨é€å¤±è´¥è‡ªåŠ¨é‡è¯•3æ¬¡" >> $GITHUB_STEP_SUMMARY
        fi
