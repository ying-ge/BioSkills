name: Backup GitHub R Packages (One by One)
 
on:
  workflow_dispatch:
  #schedule:
  #  - cron: "0 2 * * 0"
 
permissions:
  contents: write
  actions: read
 
jobs:
  backup-packages:
    runs-on: ubuntu-latest
    
    env:
      GITHUB_PAT: ${{ secrets.GITHUB_TOKEN }}
 
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0
 
    - name: Set up R
      uses: r-lib/actions/setup-r@v2
      with:
        r-version: "4.3"
        use-public-rspm: true
 
    - name: Install R dependencies
      uses: r-lib/actions/setup-r-dependencies@v2
      with:
        packages: |
          any::jsonlite
          any::httr
        cache-version: 2
 
    - name: Configure Git
      run: |
        git config --global user.name "GitHub Actions Bot"
        git config --global user.email "actions@github.com"
 
    - name: Create and run one-by-one backup script
      run: |
        cat > backup_one_by_one.R << 'EOF'
        library(jsonlite)
        library(httr)
        
        github_token <- Sys.getenv("GITHUB_PAT")
        if (github_token != "") {
          httr::set_config(httr::add_headers(Authorization = paste("token", github_token)))
        }
        
        # 读取仓库列表
        read_github_repos <- function(file_path) {
          if (!file.exists(file_path)) {
            stop("文件不存在: ", file_path)
          }
          
          lines <- readLines(file_path, warn = FALSE)
          lines <- lines[lines != "" & !grepl("^#", lines)]
          
          repos <- character(0)
          for (line in lines) {
            if (grepl("github.com", line)) {
              repo <- gsub(".*github.com/([^/]+/[^/]+).*", "\\1", line)
              repos <- c(repos, repo)
            } else if (grepl("^[^/]+/[^/]+$", trimws(line))) {
              repos <- c(repos, trimws(line))
            }
          }
          
          return(unique(repos))
        }
        
        # 单个仓库备份函数
        backup_single_repo <- function(repo, backup_dir = "R_packages_backup", max_file_size_mb = 100) {
          repo_name <- gsub("/", "_", repo)
          repo_dir <- file.path(backup_dir, repo_name)
          
          # 清理可能存在的旧目录
          if (dir.exists(repo_dir)) {
            unlink(repo_dir, recursive = TRUE)
          }
          
          if (!dir.exists(backup_dir)) {
            dir.create(backup_dir, recursive = TRUE)
          }
          dir.create(repo_dir)
          
          cat("🔄 正在备份:", repo, "\n")
          
          result <- list(
            repo = repo,
            status = "failed",
            download_date = as.character(Sys.Date()),
            file_size_mb = 0,
            commit_hash = NA
          )
          
          tryCatch({
            # 尝试下载主分支
            zip_urls <- c(
              paste0("https://github.com/", repo, "/archive/refs/heads/master.zip"),
              paste0("https://github.com/", repo, "/archive/refs/heads/main.zip")
            )
            
            downloaded <- FALSE
            final_file <- NULL
            
            for (j in seq_along(zip_urls)) {
              branch_name <- c("master", "main")[j]
              zip_file <- file.path(repo_dir, paste0(repo_name, "_", branch_name, ".zip"))
              
              tryCatch({
                download.file(zip_urls[j], zip_file, mode = "wb", quiet = TRUE)
                if (file.exists(zip_file) && file.size(zip_file) > 1000) {
                  file_size_mb <- file.size(zip_file) / (1024^2)
                  
                  if (file_size_mb > max_file_size_mb) {
                    cat(sprintf("⚠️ 文件过大 (%.1f MB > %d MB)，跳过\n", file_size_mb, max_file_size_mb))
                    result$status <- sprintf("skipped - too large (%.1f MB)", file_size_mb)
                    result$file_size_mb <- file_size_mb
                    file.remove(zip_file)
                    return(result)
                  }
                  
                  downloaded <- TRUE
                  final_file <- zip_file
                  result$file_size_mb <- round(file_size_mb, 2)
                  break
                } else if (file.exists(zip_file)) {
                  file.remove(zip_file)
                }
              }, error = function(e) NULL)
            }
            
            if (downloaded) {
              # 获取仓库信息
              if (github_token != "") {
                api_url <- paste0("https://api.github.com/repos/", repo)
                tryCatch({
                  response <- httr::GET(api_url)
                  if (httr::status_code(response) == 200) {
                    repo_info <- httr::content(response, "text", encoding = "UTF-8")
                    meta_file <- file.path(repo_dir, "repository_info.json")
                    writeLines(repo_info, meta_file)
                    
                    # 提取commit hash
                    repo_data <- fromJSON(repo_info)
                    if (!is.null(repo_data$default_branch)) {
                      result$commit_hash <- repo_data$default_branch
                    }
                  }
                }, error = function(e) NULL)
              }
              
              result$status <- "success"
              cat(sprintf("✅ 下载成功 (%.1f MB)\n", result$file_size_mb))
            } else {
              result$status <- "failed - no accessible branch"
              cat("❌ 下载失败\n")
              unlink(repo_dir, recursive = TRUE)
            }
            
          }, error = function(e) {
            result$status <- paste("error:", e$message)
            cat("❌ 出错:", e$message, "\n")
            unlink(repo_dir, recursive = TRUE)
          })
          
          return(result)
        }
        
        # 查找仓库列表文件
        possible_paths <- c(
          ".github/docs/github_library.txt",
        )
        
        repo_file <- NULL
        for (path in possible_paths) {
          if (file.exists(path)) {
            repo_file <- path
            break
          }
        }
        
        if (is.null(repo_file)) {
          cat("未找到仓库列表文件\n")
          quit(status = 1)
        }
        
        # 读取仓库列表
        github_repos <- read_github_repos(repo_file)
        cat("找到", length(github_repos), "个仓库，将逐一处理\n\n")
        
        # 创建总日志
        all_results <- data.frame(
          repo = character(),
          status = character(),
          download_date = character(),
          file_size_mb = numeric(),
          commit_hash = character(),
          stringsAsFactors = FALSE
        )
        
        # 逐一处理每个仓库
        for (i in seq_along(github_repos)) {
          repo <- github_repos[i]
          cat(sprintf("\n=== [%d/%d] 处理仓库: %s ===\n", i, length(github_repos), repo))
          
          # 备份单个仓库
          result <- backup_single_repo(repo, max_file_size_mb = 100)
          
          # 记录结果
          all_results <- rbind(all_results, data.frame(
            repo = result$repo,
            status = result$status,
            download_date = result$download_date,
            file_size_mb = result$file_size_mb,
            commit_hash = ifelse(is.na(result$commit_hash), "", result$commit_hash),
            stringsAsFactors = FALSE
          ))
          
          # 保存当前状态的日志
          backup_dir <- "R_packages_backup"
          if (!dir.exists(backup_dir)) {
            dir.create(backup_dir, recursive = TRUE)
          }
          
          log_file <- file.path(backup_dir, paste0("backup_log_", Sys.Date(), ".csv"))
          write.csv(all_results, log_file, row.names = FALSE)
          
          # 输出当前仓库的处理结果文件，供shell脚本读取
          cat(paste(result$repo, result$status, result$file_size_mb, sep = "|"), file = "current_result.txt")
          
          cat(sprintf("📊 当前进度: %d/%d 完成\n", i, length(github_repos)))
          
          # 避免API限制
          if (i %% 5 == 0) {
            Sys.sleep(2)
          }
        }
        
        # 最终统计
        success_count <- sum(all_results$status == "success")
        skipped_count <- sum(grepl("too large", all_results$status))
        failed_count <- nrow(all_results) - success_count - skipped_count
        total_size_mb <- sum(all_results$file_size_mb[all_results$status == "success"])
        
        cat("\n\n=== 最终统计 ===\n")
        cat("总数:", nrow(all_results), "\n")
        cat("成功:", success_count, sprintf("(%.1f MB)", total_size_mb), "\n")
        cat("跳过(过大):", skipped_count, "\n")
        cat("失败:", failed_count, "\n")
        
        # 输出最终统计
        cat(paste(success_count, skipped_count, failed_count, total_size_mb, sep = "|"), file = "final_stats.txt")
        EOF
        
        # 运行R脚本，逐一处理仓库
        Rscript backup_one_by_one.R &
        r_pid=$!
        
        # 监控R脚本进度并逐一提交
        repo_count=0
        while kill -0 $r_pid 2>/dev/null; do
          # 检查是否有新的仓库处理完成
          if [ -f "current_result.txt" ]; then
            result_line=$(cat current_result.txt)
            repo_name=$(echo "$result_line" | cut -d'|' -f1)
            status=$(echo "$result_line" | cut -d'|' -f2)
            file_size=$(echo "$result_line" | cut -d'|' -f3)
            
            repo_dir_name=$(echo "$repo_name" | sed 's/\//_/g')
            
            echo ""
            echo "🔄 处理完成: $repo_name ($status)"
            
            # 提交这个仓库的备份（如果成功）
            if [ "$status" = "success" ] && [ -d "R_packages_backup/$repo_dir_name" ]; then
              echo "📦 提交 $repo_name 的备份文件..."
              
              git add "R_packages_backup/$repo_dir_name/"
              git add "R_packages_backup/backup_log_$(date +'%Y-%m-%d').csv"
              
              if ! git diff --staged --quiet; then
                if git commit -m "📦 Add backup for $repo_name (${file_size}MB) - $(date +'%Y-%m-%d %H:%M')"; then
                  echo "💾 提交成功，正在推送..."
                  
                  # 推送，带重试
                  retry=0
                  while [ $retry -lt 3 ]; do
                    if git push origin main; then
                      echo "✅ $repo_name 推送成功"
                      break
                    else
                      retry=$((retry + 1))
                      echo "⚠️ 推送失败，重试 $retry/3..."
                      sleep 5
                    fi
                  done
                  
                  if [ $retry -eq 3 ]; then
                    echo "❌ $repo_name 推送失败"
                  fi
                else
                  echo "❌ $repo_name 提交失败"
                fi
              fi
            elif [ "$status" != "success" ]; then
              echo "⚠️ $repo_name 未成功下载，跳过提交"
              # 仍然提交更新的日志
              git add "R_packages_backup/backup_log_$(date +'%Y-%m-%d').csv" 2>/dev/null || true
              git commit -m "📊 Update log for $repo_name ($status) - $(date +'%Y-%m-%d %H:%M')" 2>/dev/null || true
              git push origin main 2>/dev/null || true
            fi
            
            # 清理当前结果文件，准备下一次
            rm -f current_result.txt
            repo_count=$((repo_count + 1))
          fi
          
          sleep 3
        done
        
        # 等待R脚本完成
        wait $r_pid
        
        echo ""
        echo "🎉 所有仓库处理完成！"
        
        # 最终统计提交
        if [ -f "final_stats.txt" ]; then
          stats=$(cat final_stats.txt)
          success=$(echo "$stats" | cut -d'|' -f1)
          skipped=$(echo "$stats" | cut -d'|' -f2) 
          failed=$(echo "$stats" | cut -d'|' -f3)
          total_size=$(echo "$stats" | cut -d'|' -f4)
          
          echo "📊 最终统计: 成功 $success, 跳过 $skipped, 失败 $failed, 总大小 ${total_size}MB"
          
          # 确保最终日志被提交
          git add "R_packages_backup/backup_log_$(date +'%Y-%m-%d').csv" 2>/dev/null || true
          git commit -m "📊 Final backup summary: $success success, $skipped skipped, $failed failed - $(date +'%Y-%m-%d')" 2>/dev/null || true
          git push origin main 2>/dev/null || true
        fi
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
 
    - name: Create summary
      if: always()
      run: |
        if [ -f "final_stats.txt" ]; then
          stats=$(cat final_stats.txt)
          success=$(echo "$stats" | cut -d'|' -f1)
          skipped=$(echo "$stats" | cut -d'|' -f2) 
          failed=$(echo "$stats" | cut -d'|' -f3)
          total_size=$(echo "$stats" | cut -d'|' -f4)
          total=$((success + skipped + failed))
          
          echo "## 📊 逐一备份完成 - $(date +'%Y-%m-%d')" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| 状态 | 数量 | 说明 |" >> $GITHUB_STEP_SUMMARY
          echo "|------|------|------|" >> $GITHUB_STEP_SUMMARY
          echo "| ✅ 成功 | $success | 已备份并推送 |" >> $GITHUB_STEP_SUMMARY
          echo "| ⚠️ 跳过 | $skipped | 文件过大(>100MB) |" >> $GITHUB_STEP_SUMMARY
          echo "| ❌ 失败 | $failed | 下载失败 |" >> $GITHUB_STEP_SUMMARY
          echo "| 📦 总计 | $total | - |" >> $GITHUB_STEP_SUMMARY
          echo "| 💾 总大小 | ${total_size}MB | 已推送数据 |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ✨ 特点" >> $GITHUB_STEP_SUMMARY
          echo "- 🔄 逐一处理: 每个仓库独立下载和推送" >> $GITHUB_STEP_SUMMARY
          echo "- 📦 即时推送: 下载完成立即推送，避免累积" >> $GITHUB_STEP_SUMMARY
          echo "- 🛡️ 大小限制: 超过100MB的文件自动跳过" >> $GITHUB_STEP_SUMMARY
          echo "- 🔁 重试机制: 推送失败自动重试3次" >> $GITHUB_STEP_SUMMARY
        fi
