% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/computeDoubletDensity.R
\name{computeDoubletDensity}
\alias{computeDoubletDensity}
\alias{computeDoubletDensity,ANY-method}
\alias{computeDoubletDensity,SummarizedExperiment-method}
\alias{computeDoubletDensity,SingleCellExperiment-method}
\title{Compute the density of simulated doublets}
\usage{
computeDoubletDensity(x, ...)

\S4method{computeDoubletDensity}{ANY}(
  x,
  size.factors.norm = NULL,
  size.factors.content = NULL,
  k = 50,
  subset.row = NULL,
  niters = max(10000, ncol(x)),
  block = 10000,
  dims = 25,
  BNPARAM = KmknnParam(),
  BSPARAM = bsparam(),
  BPPARAM = SerialParam()
)

\S4method{computeDoubletDensity}{SummarizedExperiment}(x, ..., assay.type = "counts")

\S4method{computeDoubletDensity}{SingleCellExperiment}(x, size.factors.norm = sizeFactors(x), ...)
}
\arguments{
\item{x}{A numeric matrix-like object of count values, 
where each column corresponds to a cell and each row corresponds to an endogenous gene.

Alternatively, a \linkS4class{SummarizedExperiment} or \linkS4class{SingleCellExperiment} object containing such a matrix.}

\item{...}{For the generic, additional arguments to pass to specific methods.

For the SummarizedExperiment and SingleCellExperiment methods, additional arguments to pass to the ANY method.}

\item{size.factors.norm}{A numeric vector of size factors for normalization of \code{x} prior to PCA and distance calculations.
If \code{NULL}, defaults to size factors derived from the library sizes of \code{x}.

For the SingleCellExperiment method, the default values are taken from \code{\link{sizeFactors}(x)}, if they are available.}

\item{size.factors.content}{A numeric vector of size factors for RNA content normalization of \code{x} prior to simulating doublets.
This is orthogonal to the values in \code{size.factors.norm}, see Details.}

\item{k}{An integer scalar specifying the number of nearest neighbours to use to determine the bandwidth for density calculations.}

\item{subset.row}{See \code{?"\link{scran-gene-selection}"}.}

\item{niters}{An integer scalar specifying how many simulated doublets should be generated.}

\item{block}{An integer scalar controlling the rate of doublet generation, to keep memory usage low.}

\item{dims}{An integer scalar specifying the number of components to retain after the PCA.}

\item{BNPARAM}{A \linkS4class{BiocNeighborParam} object specifying the nearest neighbor algorithm.
This should be an algorithm supported by \code{\link{findNeighbors}}.}

\item{BSPARAM}{A \linkS4class{BiocSingularParam} object specifying the algorithm to use for PCA, if \code{d} is not \code{NA}.}

\item{BPPARAM}{A \linkS4class{BiocParallelParam} object specifying whether the neighbour searches should be parallelized.}

\item{assay.type}{A string specifying which assay values contain the count matrix.}
}
\value{
A numeric vector of doublet scores for each cell in \code{x}.
}
\description{
Identify potential doublet cells based on the local density of simulated doublet expression profiles.
This replaces the older \code{doubletCells} function from the \pkg{scran} package.
}
\details{
This function simulates doublets by adding the count vectors for two randomly chosen cells in \code{x}.
For each original cell, we compute the density of neighboring simulated doublets and compare it to the density of neighboring original cells.
Genuine doublets should have a high density of simulated doublets relative to the density of its neighbourhood.
Thus, the doublet score for each cell is defined as the ratio of densities of simulated doublets to the density of the original cells.

Densities are calculated in low-dimensional space after a PCA on the log-normalized expression matrix of \code{x}.
Simulated doublets are projected into the low-dimensional space using the rotation vectors computed from the original cells.
For each cell, the density of simulated doublets is computed for a hypersphere with radius set to the median distance to the \code{k} nearest neighbour.
This is normalized by \code{niters}, \code{k} and the total number of cells in \code{x} to yield the final score.

The two size factor arguments have different roles:
\itemize{
\item \code{size.factors.norm} contains the size factors to be used for normalization prior to PCA and distance calculations.
This defaults to the values returned by \code{\link{librarySizeFactors}} but can be explicitly set to ensure that the low-dimensional space is consistent with that in the rest of the analysis.
\item \code{size.factors.content} is much more important, and represents the size factors that preserve RNA content differences.
This is usually computed from spike-in RNA and ensures that the simulated doublets have the correct ratio of contributions from the original cells.
}
It is possible to set both of these arguments as they are orthogonal to each other.
Setting \code{size.factors.content} will not affect the calculation of log-normalized expression values from \code{x}.
Conversely, setting \code{size.factors.norm} will not affect the ratio in which cells are added together when simulating doublets.
}
\examples{
# Mocking up an example.
set.seed(100)
ngenes <- 1000
mu1 <- 2^rnorm(ngenes)
mu2 <- 2^rnorm(ngenes)
mu3 <- 2^rnorm(ngenes)
mu4 <- 2^rnorm(ngenes)

counts.1 <- matrix(rpois(ngenes*100, mu1), nrow=ngenes) # Pure type 1
counts.2 <- matrix(rpois(ngenes*100, mu2), nrow=ngenes) # Pure type 2
counts.3 <- matrix(rpois(ngenes*100, mu3), nrow=ngenes) # Pure type 3
counts.4 <- matrix(rpois(ngenes*100, mu4), nrow=ngenes) # Pure type 4
counts.m <- matrix(rpois(ngenes*20, mu1+mu2), nrow=ngenes) # Doublets (1 & 2)

counts <- cbind(counts.1, counts.2, counts.3, counts.4, counts.m)
clusters <- rep(1:5, c(rep(100, 4), ncol(counts.m)))

# Find potential doublets.
scores <- computeDoubletDensity(counts)
boxplot(split(log10(scores), clusters))

}
\references{
Lun ATL (2018).
Detecting doublet cells with \emph{scran}.
\url{https://ltla.github.io/SingleCellThoughts/software/doublet_detection/bycell.html}
}
\seealso{
\code{\link{findDoubletClusters}}, to detect doublet clusters.

\code{\link{scDblFinder}}, which uses a hybrid approach involving simulation and overclustering.

More detail on the mathematical background of this function is provided in the corresponding vignette at
\code{vignette("computeDoubletDensity", package="scDblFinder")}.
}
\author{
Aaron Lun
}
