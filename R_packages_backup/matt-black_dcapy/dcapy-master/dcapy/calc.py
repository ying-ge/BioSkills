import pandas as pd
import numpy as np


def initialize_result_dataframes(event_rate, thresh_lo, thresh_hi, thresh_step):
    """Initializes the net_benefit and interventions_avoided dataFrames for the
    given threshold boundaries and event rate

    Parameters
    ----------
    event_rate : float
    thresh_lo : float
    thresh_hi : float
    thresh_step : float

    Returns
    -------
    tuple(pd.DataFrame, pd.DataFrame)
        properly initialized net_benefit, interventions_avoided dataframes
    """
    #initialize threshold series for each dataFrame
    net_benefit = pd.Series(frange(thresh_lo, thresh_hi+thresh_step, thresh_step),
                            name='threshold')
    interventions_avoided = pd.DataFrame(net_benefit)

    #construct 'all' and 'none' columns for net_benefit
    net_benefit_all = event_rate - (1-event_rate)*net_benefit/(1-net_benefit)
    net_benefit_all.name = 'all'
    net_benefit = pd.concat([net_benefit, net_benefit_all], axis=1)
    net_benefit['none'] = 0

    return net_benefit, interventions_avoided


def calc_tf_positives(data, outcome, predictor, net_benefit_threshold, j):
    """Calculate the number of true/false positives for the given parameters

    Parameters
    ----------
    data : pd.DataFrame
        the data set to analyze
    outcome : str
        the column of the data frame to use as the outcome
    predictor : str
        the column to use as the predictor for this calculation
    net_benefit_threshold : pd.Series
        the threshold column of the net_benefit data frame
    j : int
        the index in the net_benefit data frame to use

    Returns
    -------
    tuple(float, float)
        the number of true positives, false positives
    """
    true_positives = false_positives = 0
    #create a filter mask
    filter_mask = data[predictor] >= net_benefit_threshold[j]
    filter_mask_sum = filter_mask.sum()
    if filter_mask_sum == 0:
        pass
    else:
        #get all outcomes where the filter_mask is 'True'
        filtered_outcomes = map(lambda x,y: x if y == True else np.nan,
                                data[outcome],filter_mask)
        filtered_outcomes = [outcome for outcome in filtered_outcomes
                             if outcome is not np.nan]  #drop all NaN values
        true_positives = mean(filtered_outcomes)*filter_mask_sum
        false_positives = (1-mean(filtered_outcomes))*filter_mask_sum

    return true_positives, false_positives


def calculate_net_benefit(index, net_benefit_threshold, harm,
                          true_positives, false_positives, num_observations):
    """Calculates the net benefit for an index within the construction of net_benefit
    loop

    This function calculates the net_benefit for a particular predictor at the given index, however
    the predictor doesn't need to be supplied to this function and should already be determined
    from the true/false positive calculation

    NOTE: true/false positives should be generated by using the calc_tf_positives
    function for the predictor of interest

    Parameters
    ----------
    net_benefit_threshold : pd.Series
        the 'threshold' column of the net_benefit dataframe for the analysis
    harm : float
        the harm value for the predictor
    true_positives : float
        the number of true positives for the given predictor
    false_positives : float
        the number of false positives for the given predictor
    num_observations : int
        the number of observations in the data set
    index : int
        the index in the Series to compute for

    Returns
    -------
    float
        value for the net benefit at `index` for the predictor
    """
    #normalize the true/false positives by the number of observations
    tp_norm = true_positives/num_observations
    fp_norm = false_positives/num_observations
    #calculate the multiplier for the false positives
    multiplier = net_benefit_threshold[index]/(1-net_benefit_threshold[index])

    return tp_norm - fp_norm*multiplier - harm


def calculate_interventions_avoided(predictor, net_benefit, intervention_per,
                                    interventions_avoided_threshold):
    """Calculate the interventions avoided for the given predictor

    Parameters
    ----------
    predictor : str
        the predictor to calculate for
    net_benefit : pd.DataFrame
        the net benefit dataframe for the analysis
    intervention_per : int
        TODO
    interventions_avoided_threshold : pd.Series
        the 'threshold' column of the interventions_avoided dataframe

    Returns
    -------
    pd.Series
        the number of interventions avoided for this predictor
    """
    net_benefit_factor = net_benefit[predictor] - net_benefit['all']
    interv_denom = (interventions_avoided_threshold/(1-interventions_avoided_threshold))

    return net_benefit_factor * intervention_per/interv_denom


def competing_risk(data, outcome, tt_outcome, use_kmf):
    """Gets the probability of the event for all subjects

    Notes
    -----
    This is used for the net benefit associated with treating all patients

    Parameters
    ----------
    data : pd.DataFrame
        the dataset to analyze
    outcome : str
        the column in `data` with outcome values
    tt_outcome : str
        the column in `data` with times to the outcome values 
    use_kmf : bool
        the algorithm to use for fitting the survival curve
        if `True`, use KaplanMeier; if `False`, use cumulative increase
    
    Returns
    -------

    """
    raise NotImplementedError()
    #construct a new dataframe of just the outcome and tt_outcome columns
    df = pd.DataFrame({outcome: data[outcome].values, 
                       tt_outcome: data[tt_outcome].values})
    if use_kmf:
        from statsmodels.sandbox.survival2 import KaplanMeier
        kmf = KaplanMeier(df.values, 1)
        kmf.fit()
    else:  # use cuminc
        pass


def lowess_smooth_results(predictor, net_benefit, interventions_avoided, 
                          lowess_frac):
    """Smooths the result data using local regression

    This function uses the index of the passed in dataframes as exogenous
    values for the smoothing

    Parameters
    ----------
    net_benefit : pd.DataFrame
        a dataframe of net benefit results
    interventions_avoided : pd.DataFrame
        a dataframe of interventions avoided results
    predictors : str
        the predictor to smooth for
        (must match a column in both net_benefit/interventions_avoided dataframes)
    lowess_frac : float
        the fraction of the data used when estimating each endogenous value

    Returns:
    --------
    tuple(pd.DataFrame, pd.DataFrame)
        smoothed net_benefit and interventions_avoided dataframes
    """
    
    #call smoothing function
    import statsmodels.api as sm
    lowess = sm.nonparametric.lowess
    smoothed_net_benefit = lowess(net_benefit[predictor], net_benefit.index.values,
                                  frac=lowess_frac, missing='drop')
    smoothed_interv = lowess(interventions_avoided[predictor],
                             interventions_avoided.index.values,
                             frac=lowess_frac, missing='drop')
    return pd.Series(smooth_net_benefit, index=net_benefit['threshold'],
                     name='{}_sm'.format(predictor)), pd.Series(
                         smooth_interv, index=interventions_avoided['threshold'],
                         name='{}_sm'.format(predictor))


def frange(start, stop, step):
    """Generator that can create ranges of floats

    Credit: http://stackoverflow.com/questions/7267226/range-for-floats

    Parameters
    ----------
    start : float
       the minimum value of the range
    stop : float
        the maximum value of the range
    step : float
        the step between values in the range

    Yields
    ------
    float
        the next number in the range `start` to `stop`-`step`
    """
    while start < stop:
        yield start
        start += step


def mean(iterable):
    """Calculates the mean of the given iterable

    Parameters
    ----------
    iterable: int, float
        an iterable of ints or floats

    Returns
    -------
    float
        the arithmetic mean of the iterable
    """
    return sum(iterable)/len(iterable)
